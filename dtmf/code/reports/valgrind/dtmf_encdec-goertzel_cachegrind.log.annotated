--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate /home/acm/Documents/heig/HPC/lab/dtmf/code/reports/valgrind/dtmf_encdec-goertzel_cachegrind.out
Command:          /home/acm/Documents/heig/HPC/lab/dtmf/code/bin/dtmf_encdec-goertzel decode output.wav
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir____________________ 

6,365,367,437 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir__________________________  file:function

< 5,425,401,863 (85.2%, 85.2%)  /home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_decode_goertzel.c:
  5,421,502,254 (85.2%)           goertzel_detect

<   879,279,734 (13.8%, 99.0%)  /home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c:
    413,014,153  (6.5%)           _dtmf_apply_bandpass
    175,218,178  (2.8%)           _dtmf_normalize_signal
    112,640,226  (1.8%)           _dtmf_pre_emphasis
     87,609,082  (1.4%)           _dtmf_calculate_noise_threshold
     75,093,494  (1.2%)           _dtmf_compute_rms
     15,644,499  (0.2%)           _dtmf_noise_reduction

<    29,050,731  (0.5%, 99.5%)  /usr/src/debug/glibc-2.41-5.fc42.x86_64/math/../sysdeps/ieee754/dbl-64/s_sin.c:
     15,014,715  (0.2%)           __cos_fma
     14,036,016  (0.2%)           __sin_fma

<    21,902,266  (0.3%, 99.8%)  /usr/lib/gcc/x86_64-redhat-linux/15/include/avxintrin.h:_dtmf_noise_reduction

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir__________________________  function:file

> 5,421,502,254 (85.2%, 85.2%)  goertzel_detect:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_decode_goertzel.c

>   413,014,153  (6.5%, 91.7%)  _dtmf_apply_bandpass:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>   175,218,178  (2.8%, 94.4%)  _dtmf_normalize_signal:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>   112,640,226  (1.8%, 96.2%)  _dtmf_pre_emphasis:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>    87,609,082  (1.4%, 97.6%)  _dtmf_calculate_noise_threshold:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>    75,093,494  (1.2%, 98.7%)  _dtmf_compute_rms:/home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>    37,546,765  (0.6%, 99.3%)  _dtmf_noise_reduction:
     21,902,266  (0.3%)           /usr/lib/gcc/x86_64-redhat-linux/15/include/avxintrin.h
     15,644,499  (0.2%)           /home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c

>    17,778,152  (0.3%, 99.6%)  __cos_fma:
     15,014,715  (0.2%)           /usr/src/debug/glibc-2.41-5.fc42.x86_64/math/../sysdeps/ieee754/dbl-64/s_sin.c

>    16,761,456  (0.3%, 99.9%)  __sin_fma:
     14,036,016  (0.2%)           /usr/src/debug/glibc-2.41-5.fc42.x86_64/math/../sysdeps/ieee754/dbl-64/s_sin.c

--------------------------------------------------------------------------------
-- Annotated source file: /home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_common.c
--------------------------------------------------------------------------------
Ir________________ 

-- line 190 ----------------------------------------
          .                 buffer = NULL;
          .                 return true;
          .             }
          .         
          .             return false;
          .         }
          .         
          .         char _dtmf_map_presses_to_letter(dtmf_count_t key, dtmf_count_t presses) {
     20,490 (0.0%)      for (int i = 0; i < dtmf_table_size; i++) {
     38,150 (0.0%)          if (dtmf_table_global[i].key == key && dtmf_table_global[i].presses == presses) {
      1,440 (0.0%)              return dtmf_table_global[i].letter;
          .                 }
          .             }
          .         
          .             debug_printf("No matching letter for key %lu with %lu presses", key, presses);
          .             return DTMF_UNKNOWN_SYMBOL;
          .         }
          .         
          1 (0.0%)  static dtmf_float_t _dtmf_compute_rms(const dtmf_float_t *buffer, dtmf_count_t const count) {
          .             assert(buffer != NULL);
          .         
          1 (0.0%)      dtmf_float_t sum_squares = 0.0;
          .         
 37,546,744 (0.6%)      for (size_t i = 0; i < count; i++) {
 37,546,740 (0.6%)          sum_squares += buffer[i] * buffer[i];
          .             }
          .         
          6 (0.0%)      return sqrt(sum_squares / (dtmf_float_t)count);
          2 (0.0%)  }
          .         
          .         static void _dtmf_noise_reduction(dtmf_float_t *buffer,
          .                                           dtmf_count_t  count,
          9 (0.0%)                                    dtmf_float_t  threshold_factor) {
          .             assert(buffer != NULL);
          .         
          1 (0.0%)      dtmf_float_t rms       = _dtmf_compute_rms(buffer, count);
          1 (0.0%)      dtmf_float_t threshold = rms * threshold_factor;
          .         
          .             const __m256d abs_mask = _mm256_castsi256_pd(_mm256_set1_epi64x(0x7FFFFFFFFFFFFFFFULL));
          .             const __m256d thr_v    = _mm256_set1_pd(threshold);
          1 (0.0%)      size_t        i        = 0;
          .             // Vectorized loop 4 samples at a time
 12,515,585 (0.2%)      for (; i + 3 < count; i += 4) {
  3,128,895 (0.0%)          __m256d v     = _mm256_loadu_pd(&buffer[i]);              // Load
          .                 __m256d abs_v = _mm256_and_pd(v, abs_mask);               // |v| = v & abs_mask
          .                 __m256d m     = _mm256_cmp_pd(abs_v, thr_v, _CMP_LT_OS);  // mask = (abs_v < threshold)
          .                 __m256d zero  = _mm256_setzero_pd();
          .                 __m256d res   = _mm256_blendv_pd(v, zero, m);  // blend to 0 or keep v
          .                 _mm256_storeu_pd(&buffer[i], res);             // store
          .             }
          .         
          2 (0.0%)      for (; i < count; ++i) {
          .                 if (fabs(buffer[i]) < threshold) {
          .                     buffer[i] = 0.0;
          .                 }
          .             }
          .         
          .             debug_printf("Noise reduction applied with dynamic threshold %f (RMS: %f, factor: %f)",
          .                          threshold, rms, threshold_factor);
          5 (0.0%)  }
          .         
          .         static void _dtmf_normalize_signal(dtmf_float_t *buffer, dtmf_count_t const count) {
          1 (0.0%)      dtmf_float_t max = 0.0;
          .             // Find maximum absolute value
 37,546,744 (0.6%)      for (dtmf_count_t i = 0; i < count; i++) {
 50,062,320 (0.8%)          if (fabs(buffer[i]) > max)
         46 (0.0%)              max = fabs(buffer[i]);
          .             }
          .             // Normalize if max is not zero
          2 (0.0%)      if (max > 0.0001) {
 37,546,744 (0.6%)          for (dtmf_count_t i = 0; i < count; i++) {
 50,062,320 (0.8%)              buffer[i] /= max;
          .                 }
          .             }
          1 (0.0%)  }
          .         
          .         static void _dtmf_apply_bandpass(dtmf_float_t *buffer, dtmf_count_t const count) {
          .             // IIR bandpass filter coefficients for 44100 Hz sample rate with some tolerance
          .             const dtmf_float_t b0 = 0.0032981, b1 = 0.0, b2 = -0.00659619, b3 = 0.0, b4 = 0.0032981;
          .             const dtmf_float_t a1 = -3.79262674, a2 = 5.43304806, a3 = -3.48434686, a4 = 0.84429627;
          8 (0.0%)      dtmf_float_t       x1 = 0, x2 = 0, x3 = 0, x4 = 0, y1 = 0, y2 = 0, y3 = 0, y4 = 0, y;
          .         
 37,546,744 (0.6%)      for (dtmf_count_t i = 0; i < count; i++) {
262,827,180 (4.1%)          y         = b0 * buffer[i] + b1 * x1 + b2 * x2 + b3 * x3 + b4 * x4 - a1 * y1 - a2 * y2 - a3 * y3 - a4 * y4;
 12,515,580 (0.2%)          x4        = x3;
 12,515,580 (0.2%)          x3        = x2;
 12,515,580 (0.2%)          x2        = x1;
 12,515,580 (0.2%)          x1        = buffer[i];
 12,515,580 (0.2%)          y4        = y3;
 12,515,580 (0.2%)          y3        = y2;
 12,515,580 (0.2%)          y2        = y1;
 12,515,580 (0.2%)          y1        = y;
 12,515,580 (0.2%)          buffer[i] = y;
          .             }
          1 (0.0%)  }
          .         
          2 (0.0%)  static dtmf_float_t _dtmf_calculate_noise_threshold(dtmf_float_t const *buffer, dtmf_count_t const count, dtmf_float_t const threshold_factor) {
          1 (0.0%)      dtmf_float_t sum    = 0.0;
          1 (0.0%)      dtmf_float_t sum_sq = 0.0;
 37,546,744 (0.6%)      for (dtmf_count_t i = 0; i < count; i++) {
 25,031,160 (0.4%)          sum += buffer[i];
 25,031,160 (0.4%)          sum_sq += buffer[i] * buffer[i];
          .             }
          5 (0.0%)      dtmf_float_t mean     = sum / (dtmf_float_t)count;
          4 (0.0%)      dtmf_float_t variance = (sum_sq / (dtmf_float_t)count) - (mean * mean);
          1 (0.0%)      dtmf_float_t stddev   = sqrt(variance);
          2 (0.0%)      return mean + threshold_factor * stddev;
          2 (0.0%)  }
          .         
          .         static void _dtmf_pre_emphasis(dtmf_float_t *buffer, dtmf_count_t const count) {
          .             const dtmf_float_t alpha = 0.95;
          1 (0.0%)      dtmf_float_t       prev  = 0.0;
          .         
 37,546,744 (0.6%)      for (dtmf_count_t i = 0; i < count; i++) {
 25,031,160 (0.4%)          dtmf_float_t current = buffer[i];
 37,546,740 (0.6%)          buffer[i]            = buffer[i] - alpha * prev;
 12,515,580 (0.2%)          prev                 = current;
          .             }
          1 (0.0%)  }
          .         
          5 (0.0%)  void _dtmf_preprocess_buffer(dtmf_float_t *buffer, dtmf_count_t frame_count, dtmf_float_t const threshold_factor) {
          .             LIKWID_MARKER_START("decode-preprocess");
          .         
          1 (0.0%)      dtmf_float_t const noise_threshold = _dtmf_calculate_noise_threshold(buffer, frame_count, threshold_factor);
          3 (0.0%)      _dtmf_noise_reduction(buffer, frame_count, noise_threshold);
          3 (0.0%)      _dtmf_normalize_signal(buffer, frame_count);
          3 (0.0%)      _dtmf_apply_bandpass(buffer, frame_count);
          3 (0.0%)      _dtmf_pre_emphasis(buffer, frame_count);
          .         
          .             LIKWID_MARKER_STOP("decode-preprocess");
          4 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/acm/Documents/heig/HPC/lab/dtmf/code/src/lib/dtmf_decode_goertzel.c
--------------------------------------------------------------------------------
Ir___________________ 

-- line 22 ----------------------------------------
            .          #define DTMF_GOE_NOISE_THRESHOLD 44
            .          #define DTMF_PREPROCESS_THRESHOLD_FACTOR 1.1
            .          
            .          // Advanced declarations
            .          static dtmf_float_t goertzel_detect(dtmf_float_t const *samples, dtmf_count_t num_samples, dtmf_float_t target_freq, dtmf_float_t sample_rate);
            .          static void         process_window(dtmf_float_t *dtmf_buffer, dtmf_count_t window_index, dtmf_count_t window_size, dtmf_float_t *max_magnitude, int *detected_key);
            .          
            .          // Goertzel algorithm implementation to detect DTMF tones
    1,635,264  (0.0%)  static dtmf_float_t goertzel_detect(dtmf_float_t const *samples, dtmf_count_t num_samples, dtmf_float_t target_freq, dtmf_float_t sample_rate) {
    2,180,352  (0.0%)      int          k      = (int)(0.5 + (((dtmf_float_t)num_samples * target_freq) / sample_rate));
    1,362,720  (0.0%)      dtmf_float_t omega  = (M_2_PI * k) / (dtmf_float_t)num_samples;
      817,632  (0.0%)      dtmf_float_t sine   = sin(omega);
      817,632  (0.0%)      dtmf_float_t cosine = cos(omega);
      545,088  (0.0%)      dtmf_float_t coeff  = 2.0 * cosine;
      545,088  (0.0%)      dtmf_float_t q0 = 0, q1 = 0, q2 = 0;
            .          
            .              // Precompute window function values
            .              static dtmf_float_t window[DTMF_GOE_MAX_SAMPLES];
            .              static int          window_initialized = 0;
      545,088  (0.0%)      if (!window_initialized) {
       11,404  (0.0%)          for (dtmf_count_t i = 0; i < DTMF_GOE_MAX_SAMPLES; i++) {
       45,600  (0.0%)              window[i] = 0.54 - 0.46 * cos((2 * M_PI * (dtmf_float_t)i) / (dtmf_float_t)(DTMF_GOE_MAX_SAMPLES - 1));
            .                  }
            2  (0.0%)          window_initialized = 1;
            .              }
            .          
            .              LIKWID_MARKER_START("decode-goe-magnitude");
1,803,968,736 (28.3%)      for (dtmf_count_t i = 0; i < num_samples; i++) {
1,201,919,040 (18.9%)          dtmf_float_t windowed_sample = samples[i] * window[i];
1,201,919,040 (18.9%)          q0                           = coeff * q1 - q2 + windowed_sample;
  600,959,520  (9.4%)          q2                           = q1;
  600,959,520  (9.4%)          q1                           = q0;
            .              }
            .          
      545,088  (0.0%)      dtmf_float_t real      = (q1 - q2 * cosine);
      272,544  (0.0%)      dtmf_float_t imag      = (q2 * sine);
    1,090,176  (0.0%)      dtmf_float_t magnitude = sqrt(real * real + imag * imag);
            .              LIKWID_MARKER_STOP("decode-goe-magnitude");
            .          
            .              return magnitude;
    1,362,720  (0.0%)  }
            .          
            .          // Process a window of DTMF samples
      136,272  (0.0%)  static void process_window(dtmf_float_t *dtmf_buffer, dtmf_count_t window_index, dtmf_count_t window_size, dtmf_float_t *max_magnitude, int *detected_key) {
       11,356  (0.0%)      *max_magnitude = 0;
       11,356  (0.0%)      *detected_key  = -1;
            .          
      454,240  (0.0%)      for (int key = 1; key <= DTMF_NUM_TONES; key++) {
      136,272  (0.0%)          dtmf_float_t magnitude =
    1,635,264  (0.0%)              goertzel_detect(dtmf_buffer + window_index, window_size, DTMF_FREQUENCIES_MAP[key - 1].low, DTMF_SAMPLE_RATE_HZ) +
      681,360  (0.0%)              goertzel_detect(dtmf_buffer + window_index, window_size, DTMF_FREQUENCIES_MAP[key - 1].high, DTMF_SAMPLE_RATE_HZ);
            .          
      272,544  (0.0%)          if (magnitude > *max_magnitude) {
       32,407  (0.0%)              *max_magnitude = magnitude;
       97,221  (0.0%)              *detected_key  = key;
            .                  }
            .              }
            .          
       34,068  (0.0%)      if (*max_magnitude < DTMF_GOE_NOISE_THRESHOLD) {
        8,016  (0.0%)          *detected_key = -1;
            .              }
       90,848  (0.0%)  }
            .          
           12  (0.0%)  bool dtmf_decode(dtmf_float_t *dtmf_buffer, dtmf_count_t const frame_count, char **out_message, dtmf_count_t *out_chars_read) {
            .              assert(dtmf_buffer != NULL);
            .              assert(frame_count > 0);
            .              assert(out_message != NULL);
            .              assert(out_chars_read != NULL);
            .              DTMF_DEBUG("Decoding DTMF signal using Goertzel...");
            .          
            .              LIKWID_MARKER_START("decode-goe");
            .          
            .              const dtmf_count_t window_size = DTMF_TONE_REPEAT_NUM_SAMPLES;
            .              const dtmf_count_t stride_size = DTMF_TONE_REPEAT_NUM_SAMPLES / 2;
            .          
            3  (0.0%)      dtmf_count_t message_length     = 0;
            6  (0.0%)      dtmf_count_t max_message_length = frame_count / stride_size + 1;
            3  (0.0%)      *out_message                    = (char *)calloc(max_message_length, sizeof(char));
            2  (0.0%)      if (!*out_message) {
            .                  fprintf(stderr, "Error: Could not allocate memory for output message\n");
            .                  LIKWID_MARKER_STOP("decode-goe");
            .                  return 0;
            .              }
            .          
            1  (0.0%)      int                last_detected_key = -1;
            1  (0.0%)      dtmf_count_t       chunks_seen       = 0;
            1  (0.0%)      dtmf_count_t       repetitions       = 0;
            1  (0.0%)      dtmf_count_t       pause_repetitions = 0;
            1  (0.0%)      dtmf_count_t       key_cooldown      = 0;
            .              dtmf_count_t const debounce_window   = DTMF_TONE_NUM_SAMPLES / stride_size;
            .          
            4  (0.0%)      _dtmf_preprocess_buffer(dtmf_buffer, frame_count, DTMF_PREPROCESS_THRESHOLD_FACTOR);
            .          
            .              LIKWID_MARKER_START("decode-goe-mainloop");
       45,429  (0.0%)      for (dtmf_count_t i = 0; i + window_size <= frame_count; i += stride_size) {
            .                  dtmf_float_t max_magnitude;
            .                  int          detected_key;
            .          
       68,136  (0.0%)          process_window(dtmf_buffer, i, window_size, &max_magnitude, &detected_key);
       34,068  (0.0%)          if (detected_key != -1) {
       14,696  (0.0%)              if (last_detected_key == -1) {
            .                          last_detected_key = detected_key;
          360  (0.0%)                  chunks_seen       = 1;
       13,976  (0.0%)              } else if (last_detected_key == detected_key) {
        6,988  (0.0%)                  (chunks_seen)++;
            .                      } else {
       24,266  (0.0%)                  chunks_seen       = 1;
            .                          repetitions       = 0;
            .                          last_detected_key = detected_key;
            .                      }
       14,336  (0.0%)              pause_repetitions = 0;
            .                  } else {
        4,008  (0.0%)              (pause_repetitions)++;
            .          
        8,016  (0.0%)              if (chunks_seen >= 4) {
          919  (0.0%)                  (repetitions)++;
          919  (0.0%)                  chunks_seen = 0;
            .                      }
            .          
       26,561  (0.0%)              if (pause_repetitions >= 4 && last_detected_key != -1 && (chunks_seen >= 3 || repetitions > 0)) {
        2,513  (0.0%)                  repetitions += (chunks_seen >= 3) ? 1 : 0;
        1,077  (0.0%)                  char letter                        = _dtmf_map_presses_to_letter((dtmf_count_t)last_detected_key, repetitions);
        2,513  (0.0%)                  (*out_message)[(message_length)++] = letter;
            .          
            .                          last_detected_key = -1;
          359  (0.0%)                  repetitions       = 0;
          718  (0.0%)                  chunks_seen       = 0;
          359  (0.0%)                  pause_repetitions = 0;
          359  (0.0%)                  key_cooldown      = debounce_window;
            .                      }
            .                  }
            .          
       21,994  (0.0%)          if (key_cooldown > 0) {
        5,744  (0.0%)              (key_cooldown)--;
            .                  }
            .          
            .                  debug_printf("Window at %lu detected key %d (mag=%.2f)", i, detected_key, max_magnitude);
            .              }
            .              LIKWID_MARKER_STOP("decode-goe-mainloop");
            .          
            .          
            9  (0.0%)      if (last_detected_key != -1 && (chunks_seen >= 3 || repetitions > 0)) {
            5  (0.0%)          repetitions += (chunks_seen >= 3) ? 1 : 0;
            3  (0.0%)          char letter                      = _dtmf_map_presses_to_letter((dtmf_count_t)last_detected_key, repetitions);
            7  (0.0%)          (*out_message)[message_length++] = letter;
            .              }
            .          
            3  (0.0%)      *out_chars_read = message_length;
            .          
            .              LIKWID_MARKER_STOP("decode-goe");
            .          
            .              DTMF_DEBUG("Message successfully decoded.");
            .              DTMF_SUCCEED();
            9  (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /usr/lib/gcc/x86_64-redhat-linux/15/include/avxintrin.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 144 ----------------------------------------
        .         {
        .           return (__m256) __builtin_ia32_addsubps256 ((__v8sf)__A, (__v8sf)__B);
        .         }
        .         
        .         
        .         extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_and_pd (__m256d __A, __m256d __B)
        .         {
6,257,790 (0.1%)    return (__m256d) __builtin_ia32_andpd256 ((__v4df)__A, (__v4df)__B);
        .         }
        .         
        .         extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_and_ps (__m256 __A, __m256 __B)
        .         {
        .           return (__m256) __builtin_ia32_andps256 ((__v8sf)__A, (__v8sf)__B);
        .         }
        .         
-- line 160 ----------------------------------------
-- line 197 ----------------------------------------
        .         #define _mm256_blend_ps(X, Y, M)					\
        .           ((__m256) __builtin_ia32_blendps256 ((__v8sf)(__m256)(X),		\
        .         				       (__v8sf)(__m256)(Y), (int)(M)))
        .         #endif
        .         
        .         extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_blendv_pd (__m256d __X, __m256d __Y, __m256d __M)
        .         {
6,257,790 (0.1%)    return (__m256d) __builtin_ia32_blendvpd256 ((__v4df)__X,
        .         					       (__v4df)__Y,
        .         					       (__v4df)__M);
        .         }
        .         
        .         extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_blendv_ps (__m256 __X, __m256 __Y, __m256 __M)
        .         {
        .           return (__m256) __builtin_ia32_blendvps256 ((__v8sf)__X,
-- line 213 ----------------------------------------
-- line 363 ----------------------------------------
        .         {
        .           return (__m256) __builtin_ia32_xorps256 ((__v8sf)__A, (__v8sf)__B);
        .         }
        .         
        .         #ifdef __OPTIMIZE__
        .         extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_cmp_pd (__m256d __X, __m256d __Y, const int __P)
        .         {
3,128,895 (0.0%)    return (__m256d) __builtin_ia32_cmppd256 ((__v4df)__X, (__v4df)__Y,
        .         					    __P);
        .         }
        .         
        .         extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_cmp_ps (__m256 __X, __m256 __Y, const int __P)
        .         {
        .           return (__m256) __builtin_ia32_cmpps256 ((__v8sf)__X, (__v8sf)__Y,
        .         					   __P);
-- line 379 ----------------------------------------
-- line 829 ----------------------------------------
        .         _mm256_store_ps (float *__P, __m256 __A)
        .         {
        .           *(__m256 *)__P = __A;
        .         }
        .         
        .         extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_loadu_pd (double const *__P)
        .         {
3,128,895 (0.0%)    return *(__m256d_u *)__P;
        .         }
        .         
        .         extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_storeu_pd (double *__P, __m256d __A)
        .         {
3,128,895 (0.0%)    *(__m256d_u *)__P = __A;
        .         }
        .         
        .         extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_loadu_ps (float const *__P)
        .         {
        .           return *(__m256_u *)__P;
        .         }
        .         
-- line 851 ----------------------------------------
-- line 1258 ----------------------------------------
        .         {
        .           return __extension__ (__m256i)(__v4di){ __D, __C, __B, __A };
        .         }
        .         
        .         /* Create a vector with all elements equal to A.  */
        .         extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_set1_pd (double __A)
        .         {
        1 (0.0%)    return __extension__ (__m256d){ __A, __A, __A, __A };
        .         }
        .         
        .         /* Create a vector with all elements equal to A.  */
        .         extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .         _mm256_set1_ps (float __A)
        .         {
        .           return __extension__ (__m256){ __A, __A, __A, __A,
        .         				 __A, __A, __A, __A };
-- line 1274 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc-2.41-5.fc42.x86_64/math/../sysdeps/ieee754/dbl-64/s_sin.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc-2.41-5.fc42.x86_64/math/../sysdeps/ieee754/dbl-64/s_sin.c

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir___________________ 

6,326,583,863 (99.4%)    annotated: files known & above threshold & readable, line numbers known
            0            annotated: files known & above threshold & readable, line numbers unknown
            0          unannotated: files known & above threshold & two or more non-identical
   29,050,731  (0.5%)  unannotated: files known & above threshold & unreadable 
    8,910,401  (0.1%)  unannotated: files known & below threshold
      822,442  (0.0%)  unannotated: files unknown

